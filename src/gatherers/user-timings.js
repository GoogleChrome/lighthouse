/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Gather = require('./gather');
const TimelineModel = require('../lib/traces/devtools-timeline-model');

class UserTimings extends Gather {
  get name() {
    return 'userTimings';
  }

  // Allow the trace to run for options.flags.trace seconds
  // in the current page, specifically to allow time for user_timing
  // events created by the site to be fired
  profiledPostPageLoad(options) {
    return new Promise((resolve, reject) => {
      setTimeout(_ => {
        resolve();
      }, options.flags.pageDwellTime * 1000);
    });
  }

  // Extract blink.user_timing events generated by the site
  postProfiling(options, tracingData) {
    if (typeof tracingData === 'undefined' ||
        !tracingData.traceContents ||
        !Array.isArray(tracingData.traceContents)) {
      this.artifact = [];
      return;
    }

    let userTimings = [];
    let navigationStartTime;
    let measuresStartTimes = {};
    let traceStart = false;

    // Fetch blink.user_timing events from the tracing data
    const timelineModel = new TimelineModel(tracingData.traceContents);
    const modeledTraceData = timelineModel.timelineModel();
    modeledTraceData.mainThreadEvents().filter(
      // Get all blink.user_timing events
      ut => ut.hasCategory('blink.user_timing') || ut.name === 'TracingStartedInPage'
    ).forEach(ut => {
      if (ut.phase === 'R' || ut.phase === 'I') {
        // Mark event
        if (ut.name === 'TracingStartedInPage' && !traceStart) {
          traceStart = true;
          return;
        }
        if (ut.name === 'navigationStart' && traceStart & !navigationStartTime) {
          navigationStartTime = ut.startTime;
        }

        if (!ut.args.hasOwnProperty('frame') && ut.name !== 'requestStart') {
          userTimings.push({
            name: ut.name,
            isMark: true,        // defines type of performance metric
            args: ut.args,
            startTime: ut.startTime
          });
        }
      } else if (ut.phase === 'b') {
        // Beginning of measure event
        measuresStartTimes[ut.name] = ut.startTime;
      } else if (ut.phase === 'e') {
        // End of measure event
        if (!ut.args.hasOwnProperty('frame') && ut.name !== 'requestStart') {
          userTimings.push({
            name: ut.name,
            isMark: false,
            args: ut.args,
            startTime: measuresStartTimes[ut.name],
            duration: ut.startTime - measuresStartTimes[ut.name],
            endTime: ut.startTime
          });
        }
      } else {
        // End
        console.log('Got a strange event:');
        console.log(ut);
      }
    });

    userTimings.forEach(ut => {
      ut.startTime = (ut.startTime - navigationStartTime).toFixed(2) + 'ms';
      if (!ut.isMark) {
        ut.endTime = (ut.endTime - navigationStartTime).toFixed(2) + 'ms';
        ut.duration = ut.duration.toFixed(2) + 'ms';
      }
    });

    this.artifact = userTimings;
  }
}

module.exports = UserTimings;
